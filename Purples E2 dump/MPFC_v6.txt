@name MPFC v6
@inputs  [Pod Cam]:wirelink [Gun1 Gun2 Gun3 Gun4]:entity [VarLib ExtraBases]:array Input_PrevWeapon Input_NextWeapon [Beacon Rotor1 Rotor2 TailRotor Prop1 Prop2 Prop3 Prop4 Prop5 Prop6 Prop7 Prop8 InstrumentPanelPosition]:vector
@outputs Fire1 Fire2 Fire3 Fire4 FireSpecial SpecialReload Aimpos:vector Gear_Down Gear_Brakes WEP Trigger_Beacon AuxOutput1 AuxOutput2 WS AD LR UD FB FCS_SuperElevation:angle
#Inbound Alerts
@outputs Alert Inbound
#Changing vars
@persist PrevWeapon NextWeapon Alt ControlSchemeChange Locked [Flight_CPU_Angle]:angle Trim FixedTrim
@persist Engine_Ignition ControlScheme Control_Ratio SelfLeveling CyclicRatio 
#Static performance variables
@persist Maneuverability Thrust Lift Cruisespeed Typeofvehicle Smoothers CollectiveSmoother ThrustSmoother StickLimits Hudcolor:vector4
@persist [Sounds]:array AngularForce AngularDamping VectorDamping ControlSchemesAvailable [Startup_Key Gear_Key]:string
@persist [Bases Inertias Unwelded]:array [CamParent Seat Pilot]:entity # [Masses]:array
@persist Flap_Effectiveness Plane_Lift_Adjustment Flap_Dampening
#Static flight template
@persist ManeuverabilityMultiplier:angle [VectorFlightMultiplier VectorDampingMultiplier]:vector Winglift RollOnYaw CollectiveThrottleBlending CyclicTailMixing StallEnabled [FlightModelName]:string
#Compiled flight model
@persist [FlightModel_Maneuverability]:angle [FlightModel_Thrust FlightModel_Damping]:vector FlightModel_Stall FlightModel_Wings FlightModel_RollOnYaw FlightModel_CollectiveThrottleBlending FlightModel_Collective FlightModel_Cyclic FlightModel_ForwardEngineThrust FlightModel_CyclicTailMixing FlightModel_SelfLeveling FlightModel_PitchYawMul
#Camera, View, and Ergonomic persists
@persist SplitTickTimer EGPSlowTimer Hide_Beacon Metric Show_Beacon CamOffset:vector Cam_FOV EyeMul FLIR ZoomLevel EyePosition:vector CamDist AimTrace:ranger
#Ballistics, ammo, and fire control
@persist NoCanFly AmmoCount ActiveAmmo Ammo1 Ammo2 Ammo3 Ammo4 FCS_Range GunSelectedEntity:entity GunSelected [FCS_OldAimAng FCS_Lead AimAng]:angle FCS_Muzvel FCS_DropTable:array Curtime ChangeGunSelected
#Fire missions
@persist FCS_FireMission [FCS_FireMissionVector FCS_ProspectiveFireMissionVector]:vector
#Holo persists
@persist RatePercentage Mode Index [RotorA RotorB]:entity [Propellor_Directions]:array Number_Of_Propellors Scale:vector RotorBlades TailScale:vector TailRotorBlades TailAngleSwap PropellorScale PropellorBlades
#Autopilot
@persist [AP_Waypoints]:array APOn AP_CurrentIndex AP_Loop:vector2 AP_Record_Key:string AP_Record AP_Pushpoint
#Override for autopilot for aiming
@persist Saved_Aimpos:vector
#Damage - experimental!
@persist DamageSystemSpeed DamageBaseCount DamageTimer
#Simple efficiency improvements
@persist Is_Armed Multi_Weapon UsedSmoother Piloted Base:entity HoloVisibleUpdate WarningPodOn
#Inbound Alert
@persist [Targets]:array
#Triggers
@trigger Input_PrevWeapon Input_NextWeapon
#Misc
@persist SplitTimer
@autoupdate on 

#[THIS CODE IS PROVIDED TO YOU COURTESY OF FRS.  OUR IP IS 70.42.74.154:27015.

SETUP:
Place upright, facing forward, and weld to your base.  Then, parent it, making sure it retains the weld.
Cam controller, pod, EGP, etc, are to be wired to linked controllers for the pilot, parented with nocollides, and close to the e2.
If applicable, use GPSes to mark the location for holo propellors, rotors, etc, and parent them to your base, then wire them.
Input_Next/PrevWeapon should autowire if you reset the e2; if this fails, you can do it manually.
Adjust variables in a separate e2--varlib, enclosed below--and wire it.  This e2 will read the settings in that, and use them.
#Because it's in a separate e2, you can use @autoupdate, to smoothly integrate newer versions without having to update your wire--wire does it automatically.

#CAM SETTINGS
Local to Parent: YES
Clientside move: YES
Localized move:  NO
Clientside zoom: NO
All others: your choice.

#OTHER VARS:
Fire1/Fire2/Fire3/Fire4 can be linked to guns, obviously.  "Beacon" is for a nav beacon, ballistics computer, etc--just a general purpose vector input
Gear_down/brakes are for if you have your own landing gear with hydraulics and weld latches (or similar system); they are only outputs
Trigger_Beacon is for things like ballistics computers or nav beacons, it sends a 1 when you're displaying beacon.  Used to turn on ballistics computers usually.
AuxOutput1/2 are just for more misc. crap, like hatches, cockpits, winches, etc.
WEP, or Wartime Emegency Power, is for if you want to weld a thruster to your arse (afterburner), or display some effect like smoke.
WS/AD/LR/UD/FB are your controls, for if you want to use holo control sticks.  I omitted them, in the interest of providing a timely release.

#[CONTROLS:
Keyboard mode:
WASD        ->  pitch/yaw
R+A/D       ->  roll
R+W/S       ->  throttle
Space/Shift ->  lift/flaps

Mouse mode:
Mouse       ->  pitch/yaw/autoroll
A/D         ->  roll (override)
W/S         ->  throttle
Space/Shift ->  lift/flaps
Mwheel      ->  collective or throttle (more relevant one)
R+Mwheel    ->  throttle or collective (less relevant one)

Both:
Mouse1      ->  Fire
Mouse2      ->  Switch guns
MouseMiddle ->  Fire special/missile (push in mousewheel)
M           ->  Fire special/missile (alternative for those without mousewheels)
R+MouseMid  ->  Reload special/missile (R+mousewheel push in)
Alt+Mwheel  ->  Zoom
PgUp/PgDn   ->  Control mode
G           ->  Landing gear
F           ->  FLIR
L           ->  Autolevel/Autohover/Bombing mode
V           ->  Cam mode change
Alt+M1/M2   ->  Adjusts trim (persistent angular offset)
HOME        ->  Reset trim to neutral
[           ->  Aux output #1
]           ->  Aux output #2
LControl    ->  Display PIP/Input Vector
B           ->  Trace ground for gyro gunsight
L. Arrow    ->  Clears Fire Mission
R. Arrow    ->  Accepts Fire Mission
END         ->  Missile alarm, hold down for use (high CPU usage!)

#Autopilot
Chat:
ap on       ->  Turns on ottopilot
ap off      ->  Turns off ottopilot
ap set      ->  Sets waypoint of index at your aim position, with an altitude of quantity above ground.
    Ex: "ap set 2500 1" sets a point where I look at, but 2500u above ground level, as the first waypoint in the computer.
ap cur      ->  Sets waypoint of index at your aim position, with the altitude relative to your height.
    Ex: "ap cur 500 1" sets a point where I look at, but 500u above my height, as the first waypoint in the computer.
ap loop     ->  Tells autopilot to loop the set points.
    Ex: "ap loop 3 5" tells the autopilot to keep flying until it hits waypoint 5, then fly from waypoint 5-3, then 3-4-5, and so on.
ap dump     ->  Dumps all autopilot waypoints, resetting to 0,0,0
ap clr      ->  ^See above^    
Keys:
Npad 1-9    ->  Inputs where you're looking, at your current altitude, as the corresponding waypoint in the flight computer.
    Ex: pressing numpad 3 is the same as "ap cur 0 3"
Npad Enter  ->  Records your current position as the next waypoint available in the flight computer.
    Ex: fly a loop, while pressing enter.  Then chat "ap loop 1 [last #]", then "ap on", and it will keep flying the path you flew over and over.

#Fire missions
Chat:
fm X        ->  Give a fire mission at aimpos.  Anyone else can do it as well.  Useful for team games or friends requesting support.
                Replace X with the first letter of your playername, case insensitive.

#CURRENT KNOWN ISSUES:
Autopilot on helis is sketchy
#ifdef commands are probably buggy.
Certain unladen base props may shudder, because I upped the force slightly beyond what's "normal".  This is to accommodate landing gear.
On spawn, it may give a UDF error.  This is wire.  Not me.  The e2 should auto-reset and you'll be good to go.
]#

interval(50)
runOnChat(1)
runOnKeys(Pilot,1)
#[FLIGHT MODELS:
0------------Glider
1------------Biplane
2------------Parasol plane
3------------Monoplane
4------------Jumpjet
5------------Airship
6------------Helicopter
7------------Gyrodyne
8------------Autogyro
]#
if(dupefinished()) {reset()}
elseif(first() | duped())
    {
        #Here we're assemblign our variable library, I left this at the top just in case you want to reference it.        
        #Performance
        Maneuverability = VarLib:number(1) * 2	#modifier for maneuverability, ignore its *2 this is purely to make varlibs easier to default to 1
        Thrust = VarLib:number(2) 			#forward or lateral thrust, it's all meshed the same
        Lift = VarLib:number(3)			#Lift force ratio, may adjust to work with some autohovering governor
        Cruisespeed = VarLib:number(4)				#max lift at this, used to create stall ratios
        Typeofvehicle = VarLib:number(5)			#selects flight model
        #Personal preferences
        Smoothers = VarLib:number(6)		#Smooths inputs of angles
        CollectiveSmoother = VarLib:number(7) 	#smoother for collective only, reduced to 50% purely to make varlibs easier to default.
        ThrustSmoother = VarLib:number(8)	#smoother for thrust only
        #Sounds
        CockpitSound = VarLib:string(11)			#Sound that plays in the cockpit
        EngineSound = VarLib:string(12)				#Sound that plays from engine, pitches with load.
        PropSound = VarLib:string(13)				#Sound that plays from rotors or thrusting, static and unchanging.
        SwitchSound = VarLib:string(14)				#Sound that plays when you switch master circuit
        GetInSound = VarLib:string(15)				#Sound that plays when someone gets in the seat
        StartSound = VarLib:string(16)      #Sound that plays as the engine turns over
        #Optional holo
        Scale = VarLib:vector(18)          #Scale of your main rotors
        RotorBlades = VarLib:number(19)   #Blades on main rotors
        TailScale = VarLib:vector(20)      #Scale of your tail rotor
        TailRotorBlades = VarLib:number(21) #Blades on tail rotor
        TailAngleSwap = VarLib:number(24) #Swaps the angle of the tail rotor
        PropellorScale = VarLib:number(22)  #Size of your propellors
        PropellorBlades = VarLib:number(23) #Blades on your propellors
        #Cam
        CamOffset = VarLib:vector(25)
        if(CamOffset == vec(0,0,0)) {CamOffset = vec(0,0,75)}
        #Global variables
        AngularForce = 10 #Angular correction force, default 9, slightly too high because landing gear/guns
        AngularDamping = 2.2 #Angular damping force, default 2, slightly too high because landing gear/guns
        VectorDamping = 0.04 #Damping of 3-dimensional movement, simulates inertia/air resistance
        Control_Ratio = 1 #Will change if you start stalling, otherwise remains defaulted to 1
        Flap_Effectiveness = 0.5 #at 1, flaps will be magic, at 0, they do nothing.  Determines a percentage to lower the effect of stall & an increase in lift at once.
        #Hard controls
        Startup_Key = "enter"
        Gear_Key = "g"
        AP_Record_Key = "pad_enter"
        
        #personal preferences you can adjust and save, this will update on all your things!
        StickLimits = 15 #Basically how fast it rolls and adjusts off your aim, low values mean it's super rollypolly like WT, high values are more like MPFC 3.  Note that autopilot is hard-coded to 15
        Hudcolor = vec4(255,255,255,128) #color of hud
        Metric = 1      #Do you believe that shutting your own government down is NOT viable political policy?
        
        #Startup error checks
        Typeofvehicle = clamp(Typeofvehicle,1,8) #Eliminates errors possibly accumulated from idiot chip users who go out of bounds.  As we code, and add better ones, we'll make this better
        
        #Flight model templates - You can analyze these and make more, if you're a competent programmer
        if(Typeofvehicle ==0)
            {ManeuverabilityMultiplier = ang(1.125,0.5,2)
            VectorFlightMultiplier = vec(0,0,0.9)
            VectorDampingMultiplier = vec(0.01,5,1)
            Winglift = 1
            ForeThrust = 0
            CyclicEnabled = 0
            CollectiveEnabled = 0
            RollOnYaw = 1
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 0
            StallEnabled = 1
            SelfLeveling = 0
            FlightModelName = "glider"}
        elseif(Typeofvehicle ==1)
            {ManeuverabilityMultiplier = ang(1.25,0.5,3)
            VectorFlightMultiplier = vec(0.7,0,0.9)
            VectorDampingMultiplier = vec(0.5,5,0.8)
            Winglift = 1
            ForeThrust = 1
            CyclicEnabled = 0
            CollectiveEnabled = 0
            RollOnYaw = 1
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 0
            StallEnabled = 1
            SelfLeveling = 0
            FlightModelName = "biplane"}
        elseif(Typeofvehicle ==2)
            {ManeuverabilityMultiplier = ang(1.125,0.5,2.75)
            VectorFlightMultiplier = vec(0.7,0,0.8)
            VectorDampingMultiplier = vec(0.4,5,1)
            Winglift = 1
            ForeThrust = 1
            CyclicEnabled = 0
            CollectiveEnabled = 0
            RollOnYaw = 1
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 0
            StallEnabled = 1
            SelfLeveling = 0
            FlightModelName = "highwing"}
        elseif(Typeofvehicle ==3)
            {ManeuverabilityMultiplier = ang(1,0.5,2.5)
            VectorFlightMultiplier = vec(0.7,0,0.7)
            VectorDampingMultiplier = vec(0.3,5,1)
            Winglift = 1
            ForeThrust = 1
            CyclicEnabled = 0
            CollectiveEnabled = 0
            RollOnYaw = 1
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 0
            StallEnabled = 1
            SelfLeveling = 0
            FlightModelName = "plane"}
        elseif(Typeofvehicle ==4)
            {ManeuverabilityMultiplier = ang(1,0.5,2.25)
            VectorFlightMultiplier = vec(0.66,0,1.9)
            VectorDampingMultiplier = vec(0.3,5,1.25)
            Winglift = 1
            ForeThrust = 1
            CyclicEnabled = 0
            CollectiveEnabled = 1
            RollOnYaw = 1
            CollectiveThrottleBlending = 0.5
            CyclicTailMixing = 0
            StallEnabled = 1
            SelfLeveling = 0
            FlightModelName = "jumpjet"}
        elseif(Typeofvehicle ==5)
            {ManeuverabilityMultiplier = ang(0.125,0.125,0.1)
            VectorFlightMultiplier = vec(0.4,0,1.5)
            VectorDampingMultiplier = vec(1.5,1.5,1.75)
            Winglift = 0
            ForeThrust = 1
            CyclicEnabled = 0
            CollectiveEnabled = 1
            RollOnYaw = 0
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 0
            StallEnabled = 0
            SelfLeveling = 1
            FlightModelName = "airship"}
        elseif(Typeofvehicle ==6)
            {ManeuverabilityMultiplier = ang(1,0.9,1.2)
            VectorFlightMultiplier = vec(1,0.7,1.75)
            VectorDampingMultiplier = vec(0.7,0.7,1)
            Winglift = 0
            ForeThrust = 0
            CyclicEnabled = 1
            CollectiveEnabled = 1
            RollOnYaw = 0
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 2
            StallEnabled = 0
            SelfLeveling = 1
            FlightModelName = "helicopter"}
        elseif(Typeofvehicle ==7)
            {ManeuverabilityMultiplier = ang(1,0.7,1.2)
            VectorFlightMultiplier = vec(1.2,0.7,1.5)
            VectorDampingMultiplier = vec(0.75,0.8,1)
            Winglift = 0
            ForeThrust = 1
            CyclicEnabled = 1
            CollectiveEnabled = 1
            RollOnYaw = 0
            CollectiveThrottleBlending = 0.3
            CyclicTailMixing = 2
            StallEnabled = 0
            SelfLeveling = 1
            FlightModelName = "gyrodyne"}
        elseif(Typeofvehicle ==8)
            {ManeuverabilityMultiplier = ang(1.0,1.1,1.25)
            VectorFlightMultiplier = vec(0.65,0.35,1.10)
            VectorDampingMultiplier = vec(0.5,2,2)
            Winglift = 0.8
            ForeThrust = 1
            CyclicEnabled = 1
            CollectiveEnabled = 0
            RollOnYaw = 0
            CollectiveThrottleBlending = 0
            CyclicTailMixing = 1
            StallEnabled = 1
            SelfLeveling = 1
            FlightModelName = "autogyro"}
        #compiling flight templates into proper model
        FlightModel_Maneuverability = ManeuverabilityMultiplier * Maneuverability
        FlightModel_Thrust = VectorFlightMultiplier * (vec(Thrust*1.25,Thrust*1.25,Lift*0.75)* 50)
        FlightModel_Stall = Cruisespeed * StallEnabled
        FlightModel_Damping = -VectorDamping * VectorDampingMultiplier
        FlightModel_Wings = Winglift
        FlightModel_ForwardEngineThrust = ForeThrust 
        FlightModel_Cyclic = CyclicEnabled
        FlightModel_Collective = CollectiveEnabled
        FlightModel_CollectiveThrottleBlending = CollectiveThrottleBlending
        FlightModel_CyclicTailMixing = CyclicTailMixing
        FlightModel_SelfLeveling = SelfLeveling
        FlightModel_RollOnYaw = RollOnYaw
        FlightModel_PitchYawMul = FlightModel_Maneuverability:pitch()/FlightModel_Maneuverability:yaw()
        #also compiling sounds into proper separated array
        Sounds = array(CockpitSound,EngineSound,PropSound,SwitchSound,GetInSound,StartSound)
        #we add self-leveling apparatus--this is if our wings level with A/D in mouse mode
        if(FlightModel_SelfLeveling != 2) 
            {SelfLeveling = FlightModel_SelfLeveling
            CyclicRatio = FlightModel_Cyclic}
        else
            {SelfLeveling = 1}
        #Resetting the adjustment of our flaps, ignore
        Plane_Lift_Adjustment = 1
        Flap_Dampening = 1
        
        #We'll use this later
        Is_Armed = Gun1:isValid()
        #Gun ammo saving!
        Ammo1 = 0
        foreach(K,V:entity = Gun1:acfLinks())
            {
                Ammo1 = Ammo1 + V:acfCapacity()
            }
        Ammo2 = 0
        foreach(K,V:entity = Gun2:acfLinks())
            {
                Ammo2 = Ammo2 + V:acfCapacity()
            }
        Ammo3 = 0
        foreach(K,V:entity = Gun3:acfLinks())
            {
                Ammo3 = Ammo3 + V:acfCapacity()
            }
        Ammo4 = 0
        foreach(K,V:entity = Gun4:acfLinks())
            {
                Ammo4 = Ammo4 + V:acfCapacity()
            }
        
        #This function gets players other than the inputted player
        function array getOtherPlayers(User:entity)
            {
                local Players = players()
                local TempOutput = array()
                foreach(K,V:entity = Players)
                    {if(V != User) {TempOutput:pushEntity(V)}}
                return TempOutput
            }
        
        #Renders FOV to a power of magnification, estimated off a 90 degree fov.
        function number fcs_FOVOffMagnification(Power:number)
            {
                return (2 * atan(2 / (2 * Power)))
            }
        #Camdist
        function void updateCamDist()
            {
                if(((ControlScheme ==3) | (ControlScheme ==4)) & (ZoomLevel ==0))
                    {
                        CamDist = clamp(CamDist + ((Input_NextWeapon - Input_PrevWeapon) * 100),0,1000)
                        Cam["FOV",number] = fcs_FOVOffMagnification(1)
                    }
                else
                    {
                        CamDist = 0
                    }   
                Cam["Distance",number] = CamDist
            }
        #Function to freeze or unfreeze a contraption
        function void freezeArray(A:array,N:number)
            {
                #ifdef entity:propFreeze(number)
                foreach(K,V:entity = A) {V:propFreeze(N)}
                #endif
            }
        #Splitting our init
        SplitTimer++
    }

elseif(SplitTimer ==1)
    {
        SplitTimer++
        #Self-wiring functionality
        Self = entity():getConstraints()
        #ifdef entity:createWire(entity,string,string)
            TempDist = 50
            foreach(K,V:entity = Self)
                {
                    if(V:type() == "gmod_wire_pod")
                        {
                            TempDist = clamp((V:pos() - entity():pos()):length(),0,TempDist)
                            if((V:pos() - entity():pos()):length() == TempDist) {ToLink = V}
                        }
                }
            entity():createWire(ToLink,"Input_NextWeapon","NextWeapon")
            entity():createWire(ToLink,"Input_PrevWeapon","PrevWeapon")
        #endif
        
        #Gathering bases and information about them
        Base = entity():isWeldedTo()
        Bases:setEntity(1,Base) #welded to + array
        Inertias:setVector(1,(Base:inertia()*-AngularForce)/Base:mass())
        #Masses:setNumber(1,Base:mass())
        Unwelded:setNumber(1,0)
        #Here we can scan through all constrained props, determine if they are applicable as bases, and use them.
        X = 2
        while(ExtraBases:entity(X-1):isValid())
            {
                Selected = ExtraBases:entity(X-1)
                if(Selected != entity():isWeldedTo())#quick check to make sure some fucktard didn't link to base
                {Inertias:setVector(X,(Selected:inertia()*-AngularForce)/Selected:mass())
                #Masses:setNumber(X,Selected:mass())
                Bases:setEntity(X,Selected)
                Unwelded:setNumber(X,!Bases:entity(X):isWeldedTo():isValid())}#NOTE: checks for ANY weld not if it's welded TO THE AIRFRAME
                X++
            }

        #Calculating count of base entities, this is for the damage system.
        DamageBaseCount = Bases:count()
        
        #Grabbing our seat, resetting our control scheme
        ControlScheme = 1
        ControlSchemesAvailable = 4
        Seat = Pod:entity("Entity")
        
        #Clearing rangers
        rangerPersist(1)
        rangerFilter(entity():getConstraints())

        #resetting our cam
        Cam["Activated",number] = 0
        #holo master for camera
        holoCreate(99,entity():toWorld(CamOffset),vec(1,1,1),entity():angles())
        holoAlpha(99,0)
        holoParent(99,entity())
        CamParent = holoEntity(99)
        Cam["Parent",entity] = CamParent
        
        #Meat and potatoes of our ballistics
        function array fcs_buildDropTable(Gun:entity,N:number,Vertical:number)#Ignore the vertical thing for now
            {
                #Early setup
                #A reference holo
                holoCreate(N,vec(0,0,0),vec(0,0,0),ang(0,0,0))
                holoAlpha(N,0)
                local ReferenceEntity = holoEntity(N)
                #Primary setups
                local Muzvel = Gun:acfMuzzleVel()
                local DragConstant = ( (3.1416 * (Gun:acfCaliber()/2)^2 )/10000)/(100*Gun:acfProjectileMass())
                local ACCEL = vec(0,0,-gravity())
                local Timescale = 0.099 #Timescale.  Perfect accuracy is at 0.066.  0.066*2 gives a still fairly good accuracy.  Drift will increase in proprtion to timescale accumulation errors.
                local Coordinates = array()
                #Initial flight setup
                local Flight = ReferenceEntity:forward():setZ(0) * (Muzvel * 39.37)
                local Pos = ReferenceEntity:pos()
                local Drag = vec(0,0,0)
                local NextPos = vec(0,0,0)
                #Used for range comparison, and drop adjustment
                local StartPos = Pos
                #Flags for data, will use for interpolation & storage later
                local TableIncrements = 20  #Range Increments
                local TableMaxRange = 800   #Maximum range, should never need to exceed 800
                local TableSlot = 1         #Slot it's attempting to insert data, start at 1
                #Stating value
                local Distance = 0
                #Backup to prevent failure on empty guns
                if(!Muzvel) {return Coordinates}
                #Actual ballistics calculation
                #This will return 4 points in an array, encoded with LOCALIZED & NORMALIZED X/Y/Z, and time for the 4th axis.
                #It is PERFECTLY accurate, and is capped at a flight time of 15s.  It is recommended not to exceed 5s.  Flight time = S*15.1 @ 0.066 
                for(N=1,151)
                    {
                        Drag = Flight:normalized()*(DragConstant*Flight:length2())/80
                        NextPos = Pos + Flight*Timescale
                        Flight = Flight + (ACCEL-Drag)*Timescale
                        #Debug
                        #holoCreate(N,NextPos)
                        #Array building--if we pass a certain point, it flags the condition being met, averages the point & its predecessor, and stores it.
                        Distance = ((NextPos - StartPos):setZ(0):length()) / 52.49343832021 #This converts to meters, and, at the same time fixes the quite stupid gmod 1.33 map scaling thing.
                        while(Distance > (TableIncrements*TableSlot))
                            {Coordinates:pushVector2(vec2(ReferenceEntity:elevation((Pos + NextPos) / 2),N*Timescale))
                            TableSlot++}
                        if(Distance > TableMaxRange)
                            {Coordinates:pushVector2(vec2(ReferenceEntity:elevation((Pos + NextPos) / 2),N*Timescale))
                            TableSlot++
                            holoDelete(N)
                            return Coordinates}
                        Pos = NextPos
                    }
                hint("Failed to build total range table!\nTable compiled out to "+(Coordinates:count()*TableIncrements)+"m!",3)
                #If we somehow, i don't even know how, failed to build a range-table.
                holoDelete(N) #Cleaning up our reference holo--I know it's a messy solution, it works though.
                return Coordinates
            }
        
        
    }

elseif(SplitTimer ==2)
    {
        SplitTimer++
        #declaring functions for our driver hints
        function void hintPilotKeyboard(Seat:entity)
            {
                Seat:hintDriver("WASD pitch & yaw, R+WASD throttle/roll, SPACE/SHIFT lift",7)
            }
        function void hintPilotMouse(Seat:entity)
            {
                Seat:hintDriver("Use MOUSE to control direction",5)
                if(FlightModel_SelfLeveling)
                    {Seat:hintDriver("ALT+MOUSEWHEEL/WASD throttle/roll, R+MOUSEWHEEL/SPACE/SHIFT lift",7)}
                else
                    {Seat:hintDriver("R+MOUSEWHEEL/WS throttle, A/D & ALT+MOUSEWHEEL/SPACE/SHIFT roll/lift",7)}
            }
        
        #Fire mission scanning, uses global variables.
        function void fcs_FireMissionUpdate(Driver:entity,Aimpos:vector)
            {
                local LastChat = lastSaid():lower():explode(" ")
                if((LastChat:string(1) == "fm") | ((LastChat:string(2) == "Enemy") & (LastChat:string(1) == ">")))
                    {
                        local Eligable = 0
                        local NameOurMissionGoesTo = LastChat:string(2):lower():explode("")
                        if((NameOurMissionGoesTo:string(1) == Driver:name():lower():explode(""):string(1)) | (NameOurMissionGoesTo:string(1) == "vehicle"))
                            {Eligable = 1
                            if(lastSpoke() == Driver) {hideChat(1)} else {Seat:hintDriver("Fire mission from "+lastSpoke():name()+"!",7)}}
                        if(Eligable)
                            {
                                #Giving yourself fire missions
                                if(lastSpoke() == Driver)
                                    {hideChat(1)
                                    FCS_ProspectiveFireMissionVector = Aimpos}
                                else
                                    {FCS_ProspectiveFireMissionVector = lastSpoke():aimPos()}
                            }
                    }
            }
        #HOLO
        function array createRotors(Index,Rotor1:vector,Rotor2:vector,TailRotor:vector,Scale:vector,RotorBlades:number,TailScale:vector,TailRotorBlades:number)
            {
                #First a debug check
                local RotorBlades = clamp(RotorBlades,0,24)
                local TailRotorBlades = clamp(TailRotorBlades,0,24)
                
               #Checks for modes
                #Mode 0 = nothing
                local Mode = 0
                #Checks if it has a main rotor, returns notar
                if(Rotor1 != vec(0,0,0)) {Mode = 1}
                #Checks if it has another main rotor, returns coaxial
                if(Rotor2 != vec(0,0,0)) {Mode = 2}
                #Checks if it has a tail rotor, returns regular
                if(TailRotor != vec(0,0,0)) {Mode = 3}
                #Checks if it has properly offset rotors & tailless, returns synchro
                local OffsetRotor1 = entity():toLocal(Rotor1):y()
                local OffsetRotor2 = entity():toLocal(Rotor2):y()
                #This is related tot he above, checks which DIRECTION to tilt those rotors
                if(OffsetRotor1 > 0) {TiltForSynchroPerSide = vec2(-10,10)} else {TiltForSynchroPerSide = vec2(10,-10)}
                if((Rotor1 != vec(0,0,0)) & (Rotor2 != vec(0,0,0)) & (TailRotor == vec(0,0,0))) {if(inrange(abs(OffsetRotor1),5,abs(OffsetRotor2*1.1))) {Mode = 4}} #final check for synchro
                #Index for second rotor
                local IndexB = Index+25
                #Index for discs
                local Circle = Index+48
                local CircleB = Index+49
                #Making main rotor
                if(Mode > 0)
                    {
                        holoCreate(Index,Rotor1,vec(0.4,0.4,1) * Scale:setY(Scale:x()))
                        holoAng(Index,entity():toWorld(ang(0,0,(Mode == 4) * TiltForSynchroPerSide:x())))
                        holoModel(Index,"hq_cylinder")
                        holoParent(Index,entity())
                        local N = 1
                        while(N <= RotorBlades)
                            {
                                local Ang = (N/RotorBlades * 360)
                                local HoloAng = holoEntity(Index):toWorld(ang(0,Ang,0))
                                #Making main blade
                                holoCreate(Index+N,holoEntity(Index):pos() + (HoloAng:forward() * (Scale:x() * 44)))
                                holoScale(Index+N,vec(7,0.5,0.01) * Scale)
                                holoAng(Index+N,HoloAng)
                                holoAng(Index+N,holoEntity(Index+N):toWorld(ang(0,0,10)))
                                holoParent(Index+N,Index)
                                holoModel(Index+N,"hq_rcube")
                                #Making its control rod
                                holoCreate(Index+N+RotorBlades,holoEntity(Index):pos() + (HoloAng:forward() * (Scale:x() * 3)) + (HoloAng:right() * (Scale:y() * 2.5)) + (HoloAng:up() * (Scale:z() * -0.75)))
                                holoModel(Index+N+RotorBlades,"models/sprops/trans/misc/shock_1.mdl")
                                holoScale(Index+N+RotorBlades,Scale:setY(Scale:x())*0.4)
                                holoAng(Index+N+RotorBlades,HoloAng)
                                holoAng(Index+N+RotorBlades,holoEntity(Index+N+RotorBlades):toWorld(ang(180,0,0)))
                                holoBodygroup(Index+N+RotorBlades,0,2)
                                holoParent(Index+N+RotorBlades,Index)
                                N++
                            }
                        holoCreate(Circle,Rotor1,vec(14.2,14.2,0.05) * (Scale:setY(Scale:x())))
                        holoAng(Circle,holoEntity(Index):angles())
                        holoModel(Circle,"hq_cylinder")
                        holoAlpha(Circle,0)
                        holoParent(Circle,Index)
                        #print(holoEntity(Circle))
                    }

                #Making coaxial rotor
                if((Mode == 2) + (Mode == 4))
                    {
                        holoCreate(IndexB,Rotor2,vec(0.4,0.4,1) * Scale:setY(Scale:x()))
                        holoAng(IndexB,entity():toWorld(ang(0,0,(Mode == 4) * TiltForSynchroPerSide:y())))
                        holoModel(IndexB,"hq_cylinder")
                        holoParent(IndexB,entity())
                        local N = 1
                        while(N <= RotorBlades)
                            {
                                local Ang = (N/RotorBlades * 360)
                                local HoloAng = holoEntity(IndexB):toWorld(ang(0,Ang,0))
                                #Making main rotor
                                holoCreate(IndexB+N,holoEntity(IndexB):pos() + (HoloAng:forward() * (Scale:x() * 44)))
                                holoScale(IndexB+N,vec(7,0.5,0.01) * Scale)
                                holoAng(IndexB+N,HoloAng)
                                holoAng(IndexB+N,holoEntity(IndexB+N):toWorld(ang(0,0,-10)))
                                holoParent(IndexB+N,IndexB)
                                holoModel(IndexB+N,"hq_rcube")
                                #Making control rods
                                holoCreate(IndexB+N+RotorBlades,holoEntity(IndexB):pos() + (HoloAng:forward() * (Scale:x() * 3)) + (HoloAng:right() * (Scale:y() * 2.5)) + (HoloAng:up() * (Scale:z() * 0.25)))
                                holoModel(IndexB+N+RotorBlades,"models/sprops/trans/misc/shock_1.mdl")
                                holoScale(IndexB+N+RotorBlades,Scale:setY(Scale:x())*0.4)
                                holoAng(IndexB+N+RotorBlades,HoloAng)
                                holoAng(IndexB+N+RotorBlades,holoEntity(IndexB+N+RotorBlades):toWorld(ang(180,0,0)))
                                holoBodygroup(IndexB+N+RotorBlades,0,2)
                                holoParent(IndexB+N+RotorBlades,IndexB)
                                N++
                            }
                    }
                
                #Making tail rotor
                elseif(Mode == 3)
                    {
                        holoCreate(IndexB,TailRotor,vec(TailScale:x()*0.2,TailScale:x()*0.2,TailScale:z()*0.5))
                        holoAng(IndexB,entity():toWorld(ang(0,0,(1-(TailAngleSwap*2))*90)))
                        holoModel(IndexB,"hq_cylinder")
                        holoParent(IndexB,entity())
                        local N = 1
                        while(N <= TailRotorBlades)
                            {
                                local Ang = (N/TailRotorBlades * 360)
                                local HoloAng = holoEntity(IndexB):toWorld(ang(0,Ang,0))
                                #Making tail rotor
                                holoCreate(IndexB+N,holoEntity(IndexB):pos() + (HoloAng:forward() * (TailScale:x() * 9.5)))
                                holoScale(IndexB+N,vec(1.5,0.175,0.01) * TailScale)
                                holoAng(IndexB+N,HoloAng)
                                holoAng(IndexB+N,holoEntity(IndexB+N):toWorld(ang(0,0,-10)))
                                holoParent(IndexB+N,IndexB)
                                holoModel(IndexB+N,"hq_rcube_thick")
                                #Making tail control rods
                                holoCreate(IndexB+N+TailRotorBlades,holoEntity(IndexB):pos() + (HoloAng:forward() * (TailScale:x() * 1.25)) + (HoloAng:right() * (TailScale:y() * 1)))
                                holoModel(IndexB+N+TailRotorBlades,"models/sprops/trans/misc/shock_1.mdl")
                                holoScale(IndexB+N+TailRotorBlades,vec(TailScale:x()*0.3,TailScale:x()*0.3,TailScale:z()*0.25))
                                holoAng(IndexB+N+TailRotorBlades,HoloAng)
                                holoAng(IndexB+N+TailRotorBlades,holoEntity(IndexB+N+TailRotorBlades):toWorld(ang(180,0,0)))
                                holoBodygroup(IndexB+N+TailRotorBlades,0,2)
                                holoParent(IndexB+N+TailRotorBlades,IndexB)
                                N++
                            }
                    }
                
                #making sure our synchromesh rotors don't slap each other to bits, not a perfect algorithm but it'll do.
                if(Mode == 4) {holoAng(IndexB,holoEntity(IndexB):toWorld(ang(0,180/RotorBlades,0)))}
                
                #Indexing for future use our holo entities
                RotorA = holoEntity(Index)
                RotorB = holoEntity(IndexB)
                
                #Finally coloring & matting
                local Color = vec(96,96,96)
                local Material = "models/props_lab/door_klab01"
                local N = 0
                while(N <= CircleB)
                    {
                        if(holoEntity(Index+N):isValid())
                            {holoColor(Index+N,Color)
                            holoMaterial(Index+N,Material)}
                        N++
                    }
                
                #output array
                return array(Mode,Index,RotorA,RotorB)
            }
        #Updating the rotors to make them turn
        function void rotateRotors(Mode:number,Index:number,RotorA:entity,RotorB:entity,RatePercentage:number)
            {
                #Updating holograms
                local Doublealpha = (Mode ==3) * 0.75
                holoAng(Index,RotorA:toWorld(ang(0,150*RatePercentage,0)))                
                holoAng(Index+25,RotorB:toWorld(ang(0,-150*RatePercentage*(1-(Doublealpha*3)),0)))
                return void
            }    
        
        #Function to create a single propellor
        function number createPropellor(Index,Position:vector,Size,Blades)
            {
                #Getting blades and model
                local ActualBlades = clamp(Blades,2,5) #Keeps it working with sprops
                local Model = "models/sprops/trans/air/prop_"+ActualBlades:toString()+"b_m.mdl"
                #Making propellor itself
                holoCreate(Index,Position,vec(Size,Size,Size))
                holoModel(Index,Model)
                holoColor(Index,vec(128,128,128))
                holoParent(Index,entity())
                #Making the little circle around it
                holoCreate(Index+1,Position,vec(Size,Size,Size*0.05)*6.4)
                holoModel(Index+1,"hq_sphere")
                holoAng(Index+1,entity():toWorld(ang(90,0,0)))
                holoAlpha(Index+1,0)
                holoColor(Index+1,vec(63,63,63))
                holoParent(Index+1,entity())
                #Getting direction it spins
                local Direction = clamp(ceil(entity():toLocal(Position):y()),-1,1)
                if(Direction == 0) {Direction = 1}
                return Direction

            }
        #Function to rotate said propellor
        function void rotatePropellor(Index,Direction,Rate)
            {
                holoAng(Index,holoEntity(Index):toWorld(ang(0,0,Direction*Rate*120)))
                holoAlpha(Index+1,Rate*128)
            }
                    
        #declaring function for heading with autoroll, this is used in mouse flight mode
        function angle getHeadingAutoroll(Aimpos:vector,Anglimit,Flight_CPU_Angle:angle,SelfLeveling,CyclicRatio,Position:vector)
            {
                local Roll = 0
                local Ang = clamp((heading(entity():pos(),Flight_CPU_Angle,Aimpos)),ang(-Anglimit,-Anglimit,0),ang(Anglimit,Anglimit,0))/Anglimit
                #Autroll for planes
                if(!CyclicRatio)
                    {
                        local Yaw = Ang:yaw()
                        Roll = Yaw  * (1 - clamp((1-(abs(Yaw)/3)),-1,1))#Add some smoother here to fix this shit.
                    }
                #Autoroll for autogyro, thanks ferv!  He did this!
                elseif (Typeofvehicle==8)
                    {
                        local Yaw = Ang:yaw()
                        Roll = Yaw  * (1 - clamp((1-(abs(Yaw)/4)),-0.75,0.75))#Add some smoother here to fix this shit.
                    }
                #Autoroll for helis
                else
                    {
                        local Yaw = Ang:yaw()
                        local PitchFixed = clamp(abs(-Flight_CPU_Angle:pitch())-5,0,20)
                        Roll = (Yaw  * (1 - clamp((1-(abs(Yaw)/4)),-0.75,0.75))) * (PitchFixed / 20)#Clamps max roll at around 30 degrees
                    }
                if(SelfLeveling & !CyclicRatio) {return Ang} else {return Ang:setRoll(Roll)}
            }

        
        #declaring a function for just smoothing raw control inputs
        function number getSmoothedOutput(Var,Change,Smoother)
            {
                return clamp(clamp(Change,Var-Smoother,Var+Smoother),-1,1)
            }
        
        #declaring a function for a smoothed adjusted persist control
        function number getAccumulatedValue(Var,Change,Rate,LowRange,HighRange)
            {
                return clamp(Var+(Change*Rate),LowRange,HighRange)
            }
        
        #This function rotate an angle around Pitch/Yaw/Roll, ignoring all gymbal lock.  VERY useful. Used for rotating our angle master
        function angle freeRotateAngle(Angle:angle,Pitch,Yaw,Roll)
            {
                local A = Angle
                local N = 1
                    A = A:rotateAroundAxis(A:forward(),Roll)
                    A = A:rotateAroundAxis(A:up(),Yaw)
                    A = A:rotateAroundAxis(A:right(),Pitch)
                return A
            }
            
        #Global function for autopilot updating
        function void addAPIndicator(Autopilot_Waypoint_Index,Autopilot_Waypoint:vector,Pilot:entity)
            {
                Autopilot_Non_Pilot_Players = getOtherPlayers(Pilot)
                local HoloIndex = 50+Autopilot_Waypoint_Index
                holoCreate(HoloIndex,Autopilot_Waypoint,vec(5,5,5))
                holoModel(HoloIndex,"models/sprops/misc/alphanum/alphanum_"+Autopilot_Waypoint_Index:toString()+".mdl")
                holoVisible(HoloIndex,Autopilot_Non_Pilot_Players,0)
                holoVisible(HoloIndex,Pilot,1)
                holoDisableShading(HoloIndex,1)
                holoMaterial(HoloIndex,"models/wireframe")
                holoColor(HoloIndex,vec4(255,255,0,255))
            }

        #Creating our holos, now that we've declared their variables.
        #These are the rotors
        Data = createRotors(100,Rotor1,Rotor2,TailRotor,Scale,RotorBlades,TailScale,TailRotorBlades)
        Mode = Data:number(1)
        Index = Data:number(2)
        RotorA = Data:entity(3)
        RotorB = Data:entity(4)
        #These are the propellors
        Temp_Propellors = array(Prop1,Prop2,Prop3,Prop4,Prop5,Prop6,Prop7,Prop8) #Making an array of all the possible propellor spots
        foreach(K,V:vector = Temp_Propellors)
            {if(V != vec(0,0,0))
                {Number_Of_Propellors++
                Propellor_Directions:pushNumber(createPropellor(60+(Number_Of_Propellors*2),V,PropellorScale,PropellorBlades))}
            }
        
        #Flak reflector gunsights
        #Function to create an entire holographic ring lead system.  The inner ring is dispersion.  The outer ring is 1 degree.
        function number fcs_createFlakScope(I:number,Parent:entity,User:entity,Gun:entity)
            {
                #Master
                holoCreate(I,vec(0,0,0),vec(1,1,1),ang(0,0,0))
                #primary ring apparatus
                local Degrees = 1
                local RingScale = (holoEntity(I):toWorld(ang(Degrees,Degrees,0)):forward() * 250 - holoEntity(I):toWorld(ang(0,0,0)):forward() * 250):length() * 2
                holoCreate(I+1,holoEntity(I):toWorld(vec(250,0,0)))
                holoAng(I+1,holoEntity(I):toWorld(ang(90,0,0)))
                holoScaleUnits(I+1,vec(RingScale,RingScale,1))
                holoModel(I+1,"hq_torus_thin")
                #Centerpoint & Dispersion Indicator
                local Dispersion = Gun:acfSpread()
                local PointScale = (holoEntity(I):toWorld(ang(Dispersion,Dispersion,0)):forward() * 250 - holoEntity(I):toWorld(ang(0,0,0)):forward() * 250):length() * 2
                holoCreate(I+2,holoEntity(I):toWorld(vec(250,0,0)))
                holoScaleUnits(I+2,vec(PointScale,PointScale,PointScale))
                holoModel(I+2,"hq_icosphere")
                #Parenting the dot to the main sight, and the ring ot the dot--the dot will rotate
                holoParent(I+2,I)
                holoParent(I+1,I+2)
                #Visibility
                local OtherPlayers = array()
                foreach(K,V:entity = players())
                    {if(V != User) {OtherPlayers:pushEntity(V)}}
                #color/shading/visiblity
                for(N=1,2)
                    {
                        holoColor(I+N,vec4(255,192,0,96))
                        holoDisableShading(I+N,1)
                        holoVisible(I+N,OtherPlayers,0)
                    }
                holoVisible(I,players(),0)
                holoAlpha(I,0)
                holoParent(I,Parent)
                return I
            }
        #Function tied to the above function, updates the scope's position and provides output
        function angle fcs_updateFlakSight(Gun:entity,I:number,ShootPos:vector,DataTable:array,Range,LeadInput:angle,AimAngle:angle,AimPoint:vector)
            {
                if(ShootPos) {holoPos(I,ShootPos)}
                #Anglign the tilting circle downwards, removed function
                #holoAng(I+2,Gun:angles():setPitch(0))
                local AngularRatio = cos(AimAngle:pitch())
                local FixedRange = Range * AngularRatio
                local LowRange = floor(Range/20)
                local HighRange = ceil(Range/20)
                local Ratio = (Range/20) - LowRange
                local BallisticsLookup = (DataTable:vector2(LowRange) * (1-Ratio)) + (DataTable:vector2(HighRange) * (Ratio))#Table increments, roughly interpolated
                local Degrees = BallisticsLookup:y() * LeadInput * ang(-1,1,0) #--used for between-tick averaging when using the floating sight
                #Scaling the ring, also a removed function--this was for a "ring sight" system, but I want to save the code.
                #local RingScale = (holoEntity(I):toWorld(ang(Degrees:pitch(),Degrees:yaw(),0)):forward() * 250 - holoEntity(I):toWorld(ang(0,0,0)):forward() * 250):length() * 2
                #holoScaleUnits(I+1,vec(RingScale,RingScale,RingScale))
                #Rifleman's rule -- the "used" range is the cosine of the range x aim angle.  I added some averaging as well.  This is roughly accurate to within a degree.
                local LowRange = floor(FixedRange/20)
                local HighRange = ceil(FixedRange/20)
                local Ratio = (Range/20) - LowRange
                local DropAngle = ((DataTable:vector2(LowRange) * (1-Ratio)) + (DataTable:vector2(HighRange) * (Ratio))):x()
                #Angling the main sight
                holoAng(I,(Gun:pos() + (Gun:forward() * ((Gun:pos()-Aimpos):length())) - AimPoint):toAngle() -(ang(BallisticsLookup:x(),0,0) - Degrees))
                return ang(DropAngle,0,0) - Degrees
            }
        #Function which creates the lead inputs in degrees
        #You'd use it as new angle above it, itself, then make old angle = new nagle, and save old angle
        #Note it's clamped.
        function angle fcs_getFlakInputLead(DeltaCurtime:number,AimAngle:angle,LastAngle:angle,OldLeadInput:angle)
            {
                local Change = (AimAngle-LastAngle) * DeltaCurtime
                return clamp(OldLeadInput*0.8 + ((Change / -0.00572)*0.2),-15,15)#Localizing it to degrees
            }
        
        #Misc
        
        Gear_Down = 1
        AP_CurrentIndex = 1
    }

else
    {
    
    #######################
    #start main code block
    #######################
    
    if(inputClk() | changed(ControlScheme))
        {
            #Control schemes
            Alt = Pod:number("Alt")
            R = Pod:number("R")
            #Control Scheme Change
            if(!Alt & !R)
                {ZoomLevel = clamp(ZoomLevel + Input_PrevWeapon - Input_NextWeapon,0,4)
                if(Input_PrevWeapon | Input_NextWeapon)
                    {
                        #Zoom
                        if(CamDist ==0)
                            {
                                if(ZoomLevel == 0) {Cam["FOV",number] = fcs_FOVOffMagnification(1)}
                                elseif(ZoomLevel == 1) {Cam["FOV",number] = fcs_FOVOffMagnification(2.5)}
                                elseif(ZoomLevel == 2) {Cam["FOV",number] = fcs_FOVOffMagnification(5)}
                                else {Cam["FOV",number] = fcs_FOVOffMagnification(100)}
                            }
                        else
                            {
                                ZoomLevel = 0
                            }
                        #Distance                            
                        updateCamDist()
                    }
                }
            else
                {
                    PrevWeapon = Input_PrevWeapon
                    NextWeapon = Input_NextWeapon
                    if((ControlScheme ==2) | (ControlScheme ==4))
                        {
                            #Getting mousewheel
                            if(!FlightModel_SelfLeveling)
                                {Temp_UD = (PrevWeapon - NextWeapon) * !R
                                Temp_FB = (PrevWeapon - NextWeapon) * R}
                            else
                                {Temp_UD = (PrevWeapon - NextWeapon) * R
                                Temp_FB = (PrevWeapon - NextWeapon) * !R}
                            UD = getAccumulatedValue(UD,Temp_UD,CollectiveSmoother,0,1)
                            FB = getAccumulatedValue(FB,Temp_FB,ThrustSmoother,0,1)
                        }
                }
        }
    
    elseif(keyClk(Pilot) & Pod:number("Active"))
        {
            R = Pod:number("R")
            Alt = Pod:number("Alt")
            #Auxiliary outputs, for things like doors
            if(Pilot:keyPressed("lbracket"))
                {
                    AuxOutput1 = !AuxOutput1
                }
            elseif(Pilot:keyPressed("rbracket"))
                {
                    AuxOutput2 = !AuxOutput2
                }
            #Dump trim
            elseif((Pilot:keyPressed("home")) | (Pod:number("Alt")*Pod:number("Mouse1")*Pod:number("Mouse2")))
                {
                    Trim = 0
                }
            #Warning pod
            WarningPodOn = Pilot:keyPressed("end")
            if(changed(WarningPodOn))
                {
                    if(WarningPodOn)
                        {TempString = "On"}
                    else
                        {TempString = "Off"
                        soundStop(101)
                        soundStop(201)}
                    Seat:hintDriver("Warning Pod: "+TempString,5)
                }

            #Fire missiles
            FireSpecial = (Pilot:keyPressed("mouse_middle") | Pilot:keyPressed("m")) * !R
            SpecialReload = (Pilot:keyPressed("mouse_middle") | Pilot:keyPressed("m")) * R
            #Control scheme change
            ControlSchemeChange = Pilot:keyPressed("pageup") - Pilot:keyPressed("pagedown")
            if(Pilot:keyPressed("V")) #Version of this just switching from outer/inner mode
                {
                    if(ControlScheme == 1) {ControlScheme = 3}
                    elseif(ControlScheme == 2) {ControlScheme = 4}
                    elseif(ControlScheme == 3) {ControlScheme = 1}
                    elseif(ControlScheme == 4) {ControlScheme = 2}
                    else {Seat:hintDriver("ERROR: Control Scheme Not Recognized",7)}
                }
            
            #Static run controlling the same engine/over feature
            if(Pilot:keyPressed(Startup_Key) & R)
                {
                    Engine_Ignition = 0
                    X = 1
                    while(X <= 6)
                        {soundStop(X)
                        X++}
                    Seat:hintDriver("Engine shutting down",7)
                    Fire1 = 0
                    Fire2 = 0
                    Fire3 = 0
                    Fire4 = 0
                    Cam["Activated",number] = 0
                    Cam["FOV",number] = fcs_FOVOffMagnification(1)
                    Cam["Distance",number] = 0
                    Cam["FLIR",number] = 0
                    Cam["Activated",number] = 0
                    Cam["FOV",number] = 100
                    holoDelete(50)
                    holoDelete(200)
                    holoDelete(201)
                    reset()
                }
            #Autopilot
            elseif(Pilot:keyPressed(AP_Record_Key))
                {
                    AP_Record = !AP_Record
                    if(AP_Record)
                        {
                            AP_Waypoints:pushVector(entity():pos())
                            Seat:hintDriver("Waypoint "+AP_Waypoints:count()+" set!",3)
                            addAPIndicator(AP_Waypoints:count(),entity():pos(),Pilot)
                        }
                }
            else
                {
                    Autopilot_Waypoint_Index = keyClkPressed():explode("_"):string(2):toNumber()
                    if(inrange(Autopilot_Waypoint_Index,1,9))
                        {
                            AP_Pushpoint = !AP_Pushpoint
                            if(AP_Pushpoint)
                                {
                                    Autopilot_Waypoint = Aimpos:setZ(entity():pos():z())
                                    AP_Waypoints:setVector(Autopilot_Waypoint_Index,Autopilot_Waypoint)
                                    Seat:hintDriver("Waypoint "+Autopilot_Waypoint_Index+" set!",3)
                                    addAPIndicator(Autopilot_Waypoint_Index,Autopilot_Waypoint,Pilot)
                                }
                        }
                    else
                        {
                            AP_Pushpoint = 0
                        }
                }
            #Fire missions
            if(!Alt)
                {
                    I = 160
                    if(Pilot:keyPressed("right"))
                        {
                            Seat:hintDriver("Fire mission accepted",3)
                            FCS_FireMission = 1
                            FCS_FireMissionVector = FCS_ProspectiveFireMissionVector
                            holoCreate(300,FCS_FireMissionVector + vec(0,0,250),vec(5,7,7),ang(90,0,0))
                            holoVisible(300,getOtherPlayers(Pilot),0)
                            holoModel(300,"models/props_phx/ww2bomb.mdl")
                            holoDisableShading(300,1)
                            holoShadow(300,0)
                            holoMaterial(300,"models/error/new light1")
                            holoColor(300,vec4(255,255,255,96))
                            soundPlay(1,0,"acf_extra/airfx/hominglocksequence1.wav")
                            #Giving the color ont he heading indicator
                            holoColor(I+13,vec(255,0,0))
                        }
                    elseif(Pilot:keyPressed("left"))
                        {
                            Seat:hintDriver("Fire mission cleared",3)
                            FCS_FireMission = 0
                            soundPlay(1,0,"acf_extra/airfx/hominglocksequence1.wav")
                            holoDelete(300)
                            holoColor(I+13,vec(255,255,255))
                        }
                }
            #Trim
            else
                {
                    Temp_TrimAdjustment = Pod:number("Mouse2") - Pod:number("Mouse1")
                    if(Temp_TrimAdjustment)
                        {Trim = clamp(Trim + Temp_TrimAdjustment*2,-10,10)}
                }
            #Landing Gear Toggle
            Gear_Down_Toggle = Pilot:keyPressed(Gear_Key)
            if(changed(Gear_Down_Toggle) & Gear_Down_Toggle)
                {Gear_Down = !Gear_Down
                soundPlay(1,0,"acf_extra/airfx/gear_down.wav")}
        }
    #everything else
    else
        {
    #Ignition and startup branch
    Piloted = Pod:number("Active")
    #Resetting the egp
    if(changed(Piloted) & Piloted) #If someone gets in or out of hte pilots seat
        {
            Pilot = Seat:driver() #Getting the pilot
            EyePosition = holoEntity(99):toLocal(Pilot:shootPos() + (entity():forward() * 5))
            #Hints
            if(!Engine_Ignition)
                {Seat:soundPlay(99,0,Sounds:string(5))
                Seat:hintDriver("Press "+Startup_Key:upper()+" to start this "+FlightModelName,7)}
            #Backcheck on legality
            if(Is_Armed)
                {if((Seat:model() != "models/vehicles/pilot_seat.mdl") & (Seat:model() != "models/nova/chair_office02.mdl"))
                    {Seat:hintDriver("Your vehicle is not legal.  Use an acf pilot seat or remove your armament.",3)
                    NoCanFly = 1}}
                
                #Creating flight instruments
                if(!InstrumentPanelPosition) {InstrumentPanelPosition = Pilot:shootPos() + (entity():forward() * 25) + (entity():up() * -5)}
                I = 160   
                #Airspeed gauge
                holoCreate(I,InstrumentPanelPosition + (entity():right() * -5.5),vec(1,1,1),entity():toWorld(ang(0,180,0)))
                holoModel(I,"models/sprops/trans/misc/gauge_1.mdl")
                holoParent(I,entity())
                #Airspeed needle master
                holoCreate(I+1,holoEntity(I):toWorld(vec(1,0,0)),vec(0.03,0.03,0.03),holoEntity(I):toWorld(ang(0,0,0)))
                holoModel(I+1,"hq_icosphere")
                holoParent(I+1,entity())
                holoColor(I+1,vec(255,0,0))
                #Airspeed needle
                holoCreate(I+2,holoEntity(I+1):toWorld(vec(0,0,-1)),vec(0.01,0.01,0.2),holoEntity(I):toWorld(ang(180,90,0)))
                holoModel(I+2,"prism")
                holoParent(I+2,I+1)
                holoColor(I+2,vec(255,0,0))
                
                #Attitude indicator
                holoCreate(I+3,InstrumentPanelPosition,vec(1,1,1),entity():toWorld(ang(0,180,0)))
                holoModel(I+3,"models/sprops/trans/misc/gauge_1.mdl")
                holoParent(I+3,entity())
                #Master ball
                holoCreate(I+4,InstrumentPanelPosition,vec(0.48,0.1,0.48),ang(0,0,90))
                holoModel(I+4,"models/sprops/geometry/t_fdisc_12.mdl")
                holoMaterial(I+4,"phoenix_storms/mat/mat_phx_metallic")
                holoParent(I+4,entity())
                #Ball's halves
                holoCreate(I+5,holoEntity(I+4):toWorld(vec(0,0,0)),vec(0.47,0.47,0.47),ang(0,0,0))
                holoModel(I+5,"models/sprops/misc/domes/size_1/dome_12x6.mdl")
                holoMaterial(I+5,"phoenix_storms/mat/mat_phx_metallic")
                holoColor(I+5,vec(64,64,0))
                holoParent(I+5,I+4)
                holoCreate(I+6,holoEntity(I+4):toWorld(vec(0,0,0)),vec(0.47,0.47,0.47),ang(0,0,180))
                holoModel(I+6,"models/sprops/misc/domes/size_1/dome_12x6.mdl")
                holoMaterial(I+6,"phoenix_storms/mat/mat_phx_metallic")
                holoParent(I+6,I+4)
                holoColor(I+6,vec(0,0,255))
                
                #Altimeter
                holoCreate(I+7,InstrumentPanelPosition + (entity():right() * 5.5),vec(1,1,1),entity():toWorld(ang(0,180,0)))
                holoModel(I+7,"models/sprops/trans/misc/gauge_1.mdl")
                holoSkin(I+7,3)
                holoParent(I+7,entity())
                #Altimeter needle master
                holoCreate(I+8,holoEntity(I+7):toWorld(vec(1,0,0)),vec(0.03,0.03,0.03),holoEntity(I+7):toWorld(ang(0,0,0)))
                holoModel(I+8,"hq_icosphere")
                holoParent(I+8,entity())
                holoColor(I+8,vec(255,0,0))
                #Altimeter needle
                holoCreate(I+9,holoEntity(I+8):toWorld(vec(0,0,-1)),vec(0.01,0.01,0.2),holoEntity(I+7):toWorld(ang(180,90,0)))
                holoModel(I+9,"prism")
                holoParent(I+9,I+8)
                holoColor(I+9,vec(255,0,0))
                #Warning bar
                holoCreate(I+10,holoEntity(I+7):toWorld(vec(0.5,0,-0.8)),vec(0.35,0.05,0.35),holoEntity(I+7):toWorld(ang(180+45,270,0)))
                holoModel(I+10,"models/sprops/geometry/qring_12.mdl")
                holoMaterial(I+10,"phoenix_storms/mat/mat_phx_metallic")
                holoParent(I+10,entity())
                holoColor(I+10,vec(64,0,0))
                #Resetting to start the altimeter
                holoAng(I+8,holoEntity(I+7):toWorld(ang(0,0,-40)))
                
                #Heading Indicator
                holoCreate(I+11,InstrumentPanelPosition + (entity():right() * -2.75) + (entity():up() * -5),vec(1,1,1),entity():toWorld(ang(0,180,0)))
                holoModel(I+11,"models/sprops/trans/misc/gauge_1.mdl")
                holoSkin(I+11,2)
                holoParent(I+11,entity())
                #Dish over it blocking it out
                holoCreate(I+12,holoEntity(I+11):toWorld(vec(0.25,0,0)),vec(0.475,0.475,0.05),holoEntity(I+11):toWorld(ang(90,0,0)))
                holoModel(I+12,"hq_cylinder")
                holoColor(I+12,vec(32,32,32))
                holoParent(I+12,entity())
                #Lil plane dude
                holoCreate(I+13,holoEntity(I+11):toWorld(vec(1.25,0,0)),vec(0.015,0.015,0.001),holoEntity(I+11):toWorld(ang(0,90,-90)))
                holoModel(I+13,"models/xqm/jetbody3.mdl")
                holoMaterial(I+13,"phoenix_storms/mat/mat_phx_metallic")
                holoColor(I+13,vec(255,255,255))
                holoParent(I+13,I+12)
                
                #RoA Indicator
                holoCreate(I+14,InstrumentPanelPosition + (entity():right() * 2.75) + (entity():up() * -5),vec(1,1,1),entity():toWorld(ang(0,180,90)))
                holoModel(I+14,"models/sprops/trans/misc/gauge_1.mdl")
                holoSkin(I+14,2)
                holoParent(I+14,entity())
                #Dish over it blocking it out
                holoCreate(I+15,holoEntity(I+14):toWorld(vec(0.25,0,0)),vec(0.32,0.32,0.05),holoEntity(I+14):toWorld(ang(90,0,0)))
                holoModel(I+15,"hq_cylinder")
                holoColor(I+15,vec(32,32,32))
                holoParent(I+15,entity())
                #RoA needle master
                holoCreate(I+16,holoEntity(I+15):toWorld(vec(0,0,0.25)),vec(0.03,0.03,0.03),entity():toWorld(ang(0,0,-90)))
                holoModel(I+16,"hq_icosphere")
                holoParent(I+16,entity())
                holoColor(I+16,vec(255,0,0))
                #RoA needle
                holoCreate(I+17,holoEntity(I+15):toWorld(vec(0,-1.3,0.25)),vec(0.015,0.015,0.2),holoEntity(I+15):toWorld(ang(0,0,90)))
                holoModel(I+17,"prism")
                holoParent(I+17,I+16)
                holoColor(I+17,vec(255,0,0))
                #Resetting RoA
                holoAng(I+16,entity():toWorld(ang(0,0,0)))
                
                #Ammo indicator
                if(Is_Armed)
                    {holoCreate(I+18,InstrumentPanelPosition + (entity():up() * 3),vec(0.05,0.05,1.25),entity():toWorld(ang(0,0,90)))
                    holoModel(I+18,"hq_rcylinder_thick")
                    holoParent(I+18,entity())
                    holoMaterial(I+18,"phoenix_storms/mat/mat_phx_metallic")
                    holoColor(I+18,vec4(64,64,64,128))
                    #Ammo Gauge
                    holoCreate(I+19,holoEntity(I+18):pos(),vec(0.04,0.04,1.23),entity():toWorld(ang(0,0,90)))
                    holoModel(I+19,"hq_rcylinder_thick")
                    holoParent(I+19,holoEntity(I+18))
                    holoMaterial(I+19,"phoenix_storms/mat/mat_phx_metallic")
                    holoColor(I+19,vec4(255,64,64,128))
                    holoDisableShading(I+19,1)
                    #holoScale(I+19,vec(0.04,0.04,1.23))
                    ActiveAmmo = Ammo1}
            
            #Fire control init
            fcs_createFlakScope(150,holoEntity(99),Pilot,Gun1)
            FCS_SuperElevation = fcs_updateFlakSight(Gun1,150,Pilot:shootPos() + (entity():forward() * 5),FCS_DropTable,FCS_Range,FCS_Lead,AimAng,Aimpos)
            GunSelected = 1
            GunSelectedEntity = Gun1
            FCS_Range = 250
            holoColor(200,vec(0,255,0))
            holoColor(201,vec(0,255,0))
            #Beacons
            holoCreate(250,entity():pos() + (entity():forward() * 2500))
            holoModel(250,"icosphere")
            holoDisableShading(250,1)
            holoScale(250,vec(4,4,4))
            holoColor(250,vec4(255,255,255,64))
            holoParent(250,99)
            holoVisible(250,Pilot,1)
            holoMaterial(250,"models/wireframe")
            
            #hiding beacons
            Others = getOtherPlayers(Pilot)
            holoVisible(250,Others,0)
            holoVisible(300,Others,0)

            #Cam active
            Cam["Activated",number] = 1
        }
    elseif(!Piloted & changed(Piloted))
        {
            Cam["Activated",number] = 0
            CamDist = 0
            updateCamDist()
            Cam["Activated",number] = 0
            Cam["FOV",number] = 100
            holoDelete(50)
            holoDelete(200)
            holoDelete(201)
            soundStop(101)
            soundStop(201)
        }
    
    #Engine ignition
    if(Engine_Ignition != 1)
        {
            if(Piloted & !NoCanFly) #Without a pilot, you cannot turn over the aircraft because there's nobody to fly it!
                {
                    Engine_Ignition = Pilot:keyPressed(Startup_Key) * !(Pod:number("R"))
                    if(changed(Engine_Ignition) & Engine_Ignition)
                        {
                            soundPlay(6,0,Sounds:string(6))
                            Engine_Ignition = 1
                        }
                }
        }
    
    #Otto von pilot
    if(chatClk(Seat:driver()))
        {
            if(lastSpoke() == Seat:driver())#Double checking--not necessary technically but i see no reason not to this branch only runs on chatclk
                {
                    Autopilot_Chat = lastSaid():lower():explode(" ")
                    #Filtering if autopilot is to be used
                    if(Autopilot_Chat:string(1) == "ap")
                        {
                            #Inits
                            hideChat(1)
                            AimTrace = rangerOffset(500000,Cam:vector("CamPos"),Cam:angle("CamAng"):forward())
                            Aimpos = AimTrace:position()
                            #What command goes into the system
                            Autopilot_Command = Autopilot_Chat:string(2)
                            #Distance height or what
                            Autopilot_Length_Input = Autopilot_Chat:string(3):toNumber()
                            #Index in the buffer
                            Autopilot_Waypoint_Index = clamp((Autopilot_Chat:string(4):toNumber()),0,9)
                            #Your position
                            Autopilot_Reference_Current_Position = entity():pos()
                            
                            #Processing
                            if(Autopilot_Command == "set")
                                {Autopilot_Waypoint = Aimpos + vec(0,0,Autopilot_Length_Input)
                                APPush = 1}
                            elseif(Autopilot_Command == "cur")
                                {Autopilot_Waypoint = Aimpos:setZ(Autopilot_Reference_Current_Position:z() + Autopilot_Length_Input)
                                APPush = 1}
                            elseif(Autopilot_Command == "dir")
                                {Autopilot_Waypoint = Autopilot_Reference_Current_Position + ((Aimpos-Autopilot_Reference_Current_Position):normalized() * Autopilot_Length_Input)
                                APPush = 1}
                            elseif(Autopilot_Command == "on")
                                {APOn = 1}
                            elseif(Autopilot_Command == "off")
                                {APOn = 0}
                            elseif(Autopilot_Command == "loop")
                                {AP_Loop = vec2(clamp(Autopilot_Length_Input,0,9),Autopilot_Waypoint_Index)
                                Seat:hintDriver("Looping "+AP_Loop:x()+" to "+AP_Loop:y()+"!",5)}
                            elseif((Autopilot_Command == "clr") | Autopilot_Command == "dump")
                                {AP_Waypoints = array()
                                for(I=1,10)
                                    {AP_Waypoints:pop()
                                    holoDelete(50+I)}
                                Seat:hintDriver("Autopilot dumped!  Now at "+AP_Waypoints:count()+" waypoints!",5)}
                            
                            #Pushing to array 
                            if((Autopilot_Waypoint != vec(0,0,0)) & APPush)
                                {
                                    AP_Waypoints:setVector(round(Autopilot_Waypoint_Index),Autopilot_Waypoint)
                                    addAPIndicator(Autopilot_Waypoint_Index,Autopilot_Waypoint,Pilot)
                                    Seat:hintDriver("Waypoint "+Autopilot_Waypoint_Index+" set!",3)
                                }
                        }
                #Remove detial prop and egp
                elseif(Autopilot_Chat:string(1) == "lowlag")
                    {
                        hideChat(1)
                        foreach(K,V:entity = entity():getConstraints())
                            {
                                if((V:mass() <= 1) & V:type() == "prop_physics")
                                    {
                                        #ifdef entity:propDelete()
                                        V:propDelete()
                                        #endif
                                    }
                            }
                        soundPlay(199,0,"misc/outer_space_transition_01.wav")
                    }
                #Freezing self
                elseif(Autopilot_Chat:string(1) == "fs")
                    {
                        hideChat(1)
                        freezeArray(entity():getConstraints(),Autopilot_Chat:string(2):toNumber())
                    }
                #Giving self fire missions
                else
                    {
                        fcs_FireMissionUpdate(Pilot,Saved_Aimpos)
                    }
                }
        }
    #Fire missions
    elseif(chatClk())
        {
            fcs_FireMissionUpdate(Pilot,Saved_Aimpos)
        }
    
    
    #Main flight branch
    elseif(Engine_Ignition) #Engine must be on
        {
            ControlScheme = ControlScheme + (ControlSchemeChange*changed(ControlSchemeChange))
            #Control scheme hints
            if(changed(ControlScheme) | changed(Engine_Ignition))
                {
                    if((ControlScheme ==1) | (ControlScheme ==2))
                        {if(ControlScheme ==1) {hintPilotKeyboard(Seat)} else {hintPilotMouse(Seat)}
                        Cam["Position",vector] = EyePosition
                        if(Is_Armed) {fcs_updateFlakSight(GunSelectedEntity,150,holoEntity(99):toWorld(EyePosition),FCS_DropTable,FCS_Range,FCS_Lead,AimAng,Cam:vector("CamPos"))}}
                    elseif((ControlScheme == 3) | (ControlScheme == 4))
                        {if(ControlScheme ==3) {hintPilotKeyboard(Seat)} else {hintPilotMouse(Seat)}
                        Cam["Position",vector] = vec(0,0,0)
                        if(Is_Armed) {fcs_updateFlakSight(GunSelectedEntity,150,holoEntity(99):pos(),FCS_DropTable,FCS_Range,FCS_Lead,AimAng,Cam:vector("CamPos"))}}
                    else
                        {if(ControlScheme > ControlSchemesAvailable) {ControlScheme = 1}
                        elseif(ControlScheme < 1) {ControlScheme = ControlSchemesAvailable}}
                    #Clamping and updating cam
                    updateCamDist()
                    #Smoothers
                    UsedSmoother = Smoothers * (1+(((ControlScheme ==2) | (ControlScheme ==4))*49))
                }
            
            #if engine just turned over
            elseif(changed(Engine_Ignition) & Engine_Ignition)
                {
                    ControlScheme = 1
                    Seat:hintDriver("Press R+"+Startup_Key:upper()+" to shut down",7)
                    WS AD LR UD FB = 0
                    Flight_CPU_Angle = entity():angles()
                    Seat:soundPlay(1,0,Sounds:string(1))
                    soundPlay(2,0,Sounds:string(2))
                    soundPlay(3,0,Sounds:string(3))
                    Seat:soundPlay(5,0,Sounds:string(5))
                    Cam_FOV = 90
                    Cam["Activated",number] = 1
                    Trim = 0
                }
            
            #Extra holo bits
            if(Mode)
                {rotateRotors(Mode,Index,RotorA,RotorB,RatePercentage)}
            if(Number_Of_Propellors)
                {N = 1
                    while(N <= Number_Of_Propellors)
                        {rotatePropellor(60+(N*2),Propellor_Directions:number(N),RatePercentage)
                        N++}
                }
    
            #Here's our main flight stuff, all this huge segment.  Surprisingly buried, isn't it?
            #If you're down here, I salute you for your dedication.  A+.  All the gold stars.
            
            #Flight constants, indexing for future use.
            Position = entity():pos()
            Velocity = entity():toLocal(Position + (Base:vel()))
            Angle = entity():angles()
            Forward = Angle:forward()
            
            if(Piloted)
                {
                    #Getting aimpoint and camera
                    AimAng = Cam:angle("CamAng")
                    AimTrace = rangerOffsetHull(500000,Cam:vector("CamPos") + (AimAng:forward()*250),AimAng:forward(),vec(50,50,50))
                    Aimpos = AimTrace:position() ##if not cam, "else {Aimpos = rangerOffset(500000,Seat:driver():shootPos(),Seat:driver():eye()):position()}"
                    Saved_Aimpos = Aimpos #We use this later.  After we run all our flight commands, which can override aimpos, this re-aligns aimpos so we can use turrets properly.
                    
                    #Getting inputs for controls
                    R = Pod:number("R")
                    if((ControlScheme ==1) | (ControlScheme ==3))
                        {
                            #Getting "buttons", lets you use R+WASD to fly one-handed if needed like for observation or gunnery.
                            if(R)
                                {Fore_Button = Pod:number("W")
                                Back_Button = Pod:number("S")
                                Left_Button = Pod:number("A")
                                Right_Button = Pod:number("D")
                                Input_WS = 0
                                Input_LR = 0}
                            else
                                {Fore_Button = 0
                                Back_Button = 0
                                Left_Button = 0
                                Right_Button = 0
                                Input_WS = Pod:number("W") - Pod:number("S")
                                Input_LR = Pod:number("D") - Pod:number("A")}
                            
                            #Getting rest of inputs
                            Input_AD = clamp((Right_Button - Left_Button + ((Pilot:keyPressed("xstick2_right") - Pilot:keyPressed("xstick2_left"))*Pilot:keyPressed("xbutton_stick2"))),-1,1)
                            if(!Pilot:keyPressed("xbutton_stick2")) {Input_LR = clamp(Input_LR + Pilot:keyPressed("xstick2_right") - Pilot:keyPressed("xstick2_left"),-1,1)} else {Input_WS = clamp(Input_WS - Pilot:keyPressed("xstick2_up") + Pilot:keyPressed("xstick2_down"),-1,1)}
                            Input_UD = clamp((Pod:number("Space") - Pod:number("Shift") + ((Pilot:keyPressed("xstick2_up") + Pilot:keyPressed("xstick2_down"))*Pilot:keyPressed("xbutton_stick2"))),-1,1)
                            Input_FB = clamp((Fore_Button - Back_Button - Pilot:keyPressed("xbutton_down") + Pilot:keyPressed("xbutton_up")),-1,1)
                        }
                    elseif((ControlScheme ==2) | (ControlScheme ==4))
                        {
                            FlightHeading = getHeadingAutoroll(Aimpos,StickLimits,Flight_CPU_Angle,FlightModel_SelfLeveling,CyclicRatio,Position)
                            Input_WS = FlightHeading:pitch()
                            if(R)
                                {OverrideInput_AD = Pod:number("Mouse2") - Pod:number("Mouse1")}
                            else
                                {OverrideInput_AD = (Pod:number("D") - Pod:number("A"))}
                            if(OverrideInput_AD == 0)
                                {Input_AD = -Flight_CPU_Angle:roll() + (FlightHeading:roll()* ((FlightModel_Maneuverability:roll() / FlightModel_Maneuverability:yaw()) * 90))}
                            else
                                {Input_AD = OverrideInput_AD - ((Flight_CPU_Angle:roll()/40) * FlightModel_SelfLeveling)}
                            Input_UD = clamp((Pod:number("Space") - Pod:number("Shift") + Pilot:keyPressed("xstick2_up") - Pilot:keyPressed("xstick2_down")),-1,1)
                            Input_LR = FlightHeading:yaw()
                            Input_AD = clamp((Input_AD + Pilot:keyPressed("xstick2_right") - Pilot:keyPressed("xstick2_left")),-1,1)
                            Input_FB = clamp((Pod:number("W") - Pod:number("S") - Pilot:keyPressed("xbutton_down") + Pilot:keyPressed("xbutton_up")),-1,1)
                        }
                    else #Error handling
                        {
                            print("ERROR: UNSUPPORTED CONTROL SCHEME, SOMETHING COCKED UP!\nSetting to ControlScheme1, was "+ControlScheme)
                            ControlScheme = 1
                        }

                    #Ballistics, jamming it here, I can't get it to run on the split-tick.
                    if(Is_Armed)
                        {
                            #Gun Selection
                            ChangeGunSelected = Pod:number("Mouse2") & !R & !Alt
                            if(ChangeGunSelected & $ChangeGunSelected) {GunSelected++}
                            #Bit of an odd way to set this up, selects between guns 1-4 with backchecks
                            if(changed(GunSelected))
                                {
                                    if((GunSelected == 2) & Gun2:isValid()) {GunSelectedEntity = Gun2}
                                    elseif(GunSelected == 3 & Gun3:isValid()) {GunSelectedEntity = Gun3}
                                    elseif(GunSelected == 4 & Gun4:isValid()) {GunSelectedEntity = Gun4}
                                    else {GunSelected = 1
                                        GunSelectedEntity = Gun1}
                                    #Redundant backcheck
                                    if(GunSelected ==1)
                                        {GunSelectedEntity = Gun1
                                        ActiveAmmo = Ammo1}
                                    elseif(GunSelected ==2)
                                        {GunSelectedEntity = Gun2
                                        ActiveAmmo = Ammo2}
                                    elseif(GunSelected ==3)
                                        {GunSelectedEntity = Gun3
                                        ActiveAmmo = Ammo3}
                                    elseif(GunSelected ==4)
                                        {GunSelectedEntity = Gun4
                                        ActiveAmmo = Ammo4}
                                    Seat:hintDriver("["+GunSelected+"] "+GunSelectedEntity:acfNameShort(),3)
                                    #Ammo
                                    AmmoCount = 0
                                    foreach(K,V:entity = GunSelectedEntity:acfLinks())
                                        {
                                            AmmoCount = AmmoCount + V:acfCapacity()
                                        }
                                }
                            #hold b to trace ground.
                            if(AimTrace:entity():isValid() | Pilot:keyPressed("B")) {FCS_Range = (Aimpos - Position):length() / 52.9343832021}
                            Curtime = curtime()
                            #Lead goes here.
                            FCS_NewAimAngle = FCS_OldAimAng - heading(Cam:vector("CamPos"),FCS_OldAimAng,Aimpos)
                            FCS_Lead = fcs_getFlakInputLead($Curtime,FCS_NewAimAngle,FCS_OldAimAng,FCS_Lead)
                            FCS_OldAimAng = FCS_NewAimAngle
                            #FCS_Lead = fcs_getFlakInputLead($Curtime,AimAng,FCS_OldAimAng,FCS_Lead)
                            #FCS_OldAimAng = AimAng #Resets aimang, just, so that we have a way to compare the delta and extrapolate conditiosn off this
                            #Updating our ballistics computer
                            FCS_SuperElevation = fcs_updateFlakSight(GunSelectedEntity,150,vec(0,0,0),FCS_DropTable,FCS_Range,FCS_Lead,AimAng,Cam:vector("CamPos"))
                            #Firing guns
                            TempFire = Pod:number("Mouse1") * (!R & !Alt) #Master firing circuit
                            Fire1 = TempFire * (GunSelected==1)
                            Fire2 = TempFire * (GunSelected==2)
                            Fire3 = TempFire * (GunSelected==3)
                            Fire4 = TempFire * (GunSelected==4)
                        }

                    #EGP & low-priority controls
                    if((SplitTickTimer == 0) | (SplitTickTimer == 2))
                        {
                            Trigger_Beacon = !Hide_Beacon
                            #Displays for the holo cockpit
                            I = 160
                            #Airspeed in knots
                            Knots = toUnit("knots",entity():vel():length())
                            holoAng(I+1,holoEntity(I):toWorld(ang(0,0,-1.77 * Knots)))
                            #Attitude indicator
                            holoAng(I+4,entity():toWorld(ang(angnorm(entity():angles():pitch()),0,-90-entity():angles():roll())))
                            #Altitude in meters, corrected for map scaling--my ballistics use the same scaling adjustments.  Don't question it.  It works.
                            Altitude = clamp(rangerOffset(50000,entity():pos(),vec(0,0,-1)):distance() / 52.49343832021,0,90) #Fixes map sacling, it's actually to units.
                            holoAng(I+8,holoEntity(I+7):toWorld(ang(0,0,-(40 + Altitude*3.5))))
                            #if fire mission, heading to that, else heading north
                            if(FCS_FireMission) {Heading = entity():bearing(FCS_FireMissionVector)} else {Heading = entity():bearing(vec(0,10000000,0))}
                            holoAng(I+13,holoEntity(I+11):toWorld(ang(Heading,90,-90)))
                            #Ascend/descent +/- 9m/s
                            AscentRate = clamp((entity():vel():z() / 5.25),-90,90)
                            holoAng(I+16,entity():toWorld(ang(0,0,clamp(AscentRate,-90,90))))
                            #Ammo indicator
                            if(Is_Armed)
                                {AmmoRatio = GunSelectedEntity:acfTotalAmmoCount() / ActiveAmmo#AmmoCount / ActiveAmmo
                                holoScale(I+19,vec(0.04,0.04,1.23 * AmmoRatio))}
                            BeaconIndicator = Position + (Forward * 250000)
                            if(Trigger_Beacon & (Beacon != vec(0,0,0)))
                                {BeaconIndicator = Beacon}
                            #Beacon
                            TempPos = Cam:vector("CamPos")
                            holoPos(250,TempPos + ((TempPos-BeaconIndicator):normalized() * -2500))
                            #Here is where I stuff shit that is to run only every few executions--this is a lag saving measure
                            #A holo timer, used to slow and accelerate the rotors and props
                            RatePercentage = clamp(RatePercentage+0.05,RatePercentage,1)
                            #Sound
                            if(CyclicRatio) {EnginePitch = 90 + (UD*20)} else {EnginePitch = 90 + (FB*20)}
                            if(changed(EnginePitch))
                                {soundPitch(2,EnginePitch)
                                soundPitch(3,EnginePitch)}
                            #FLIR
                            FLIR = Pod:number("Light")
                            if(changed(FLIR)) {Cam["FLIR",number] = FLIR}
                            #Trim Smoothing
                            Trimsmooth = Smoothers * 5
                            FixedTrim = clamp(Trim,FixedTrim-Trimsmooth,FixedTrim+Trimsmooth)
                        }
                    elseif(SplitTickTimer == 4)
                        {
                            Trigger_Beacon = 0
                            #Landing gear brakes
                            Gear_Brakes = (FB == 0) & (Input_FB == -1)
                            #Wartime emergency power or afterburner, hook it up to an external system
                            WEP = (FB * Input_FB) == 1
                            #Checking if we should rebuild range tables.
                            FCS_Muzvel = GunSelectedEntity:acfMuzzleVel()
                            if($FCS_Muzvel) {FCS_DropTable = fcs_buildDropTable(GunSelectedEntity,199,0)}
                            
                            
                            #Missile warning
                            if(WarningPodOn)
                            {
                                #Active scanning
                                F = findByClass("acf_missile")
                                Results = findToArray()
                                Targets = array()
                                foreach(K,V:entity = Results)
                                    {
                                        if(inrange(V:heading(owner():pos()),ang(-7.5,-7.5,-7.5),ang(7.5,7.5,7.5))) #
                                            {
                                                Targets:pushEntity(V)
                                            }
                                    }
                                #Warning Alert system
                                if(Targets:count())
                                    {
                                        Alert = 1
                                        #Inbound missile alert
                                        Inbound = 0
                                        foreach(K,V:entity = Targets)
                                            {
                                                if(!V:parent():isValid()) {Inbound = 1}
                                            }
                                    }
                                else
                                    {
                                        Alert = 0
                                    }
                                if(changed(Alert))
                                    {
                                        if(Alert & !Inbound)
                                            {
                                                soundPlay(101,0,"acf_extra/airfx/heatseeker_warning.wav")
                                            }
                                        else
                                            {
                                                soundStop(101)
                                            }
                                    }
                                if(changed(Inbound))
                                    {
                                        if(Alert & Inbound)
                                            {
                                                soundPlay(201,0,"acf_extra/airfx/heatseeker_lock.wav")
                                            }
                                        else
                                            {
                                                soundStop(201)
                                            }
                                    }
                            }
                        }
                    else
                        {
                            Trigger_Beacon = 0
                        }
                    SplitTickTimer = (SplitTickTimer+1) * (SplitTickTimer <= 4) #Faux intervals on ~125 and 250, respectively.
                }

            #Simple collision and damage system, runs every 5 ticks, has a 1/2 second grace period on startup.
            DamageTimer++
            if(DamageTimer == 15)
                {
                    #Damage system for impacts
                    #If you decelerate too hard, it will kill the pilot, remove random props, recolor for damage, and then go kill itself.
                    #The maximum allowed deceleration is around 40 miles an hour over the space of 1/4 of a second, at the limit of -900.
                    DamageSystemSpeed = Velocity:length()
                    if($DamageSystemSpeed < -1000)
                        {
                            Seat:soundPlay(100,0,"ambient/materials/cartrap_explode_impact2.wav")
                            Base:soundPlay(299,0,"ambient/materials/cartrap_explode_impact1.wav")
                            Seat:killPod()
                            foreach(K,V:entity = entity():getConstraints())
                                {
                                    N = random(1)
                                    if(N <= 0.1) {V:setMaterial("Models/props_trainstation/Trainstation_Ornament001")}
                                    elseif(N <= 0.2) {V:setColor(V:getColor()*vec(0.5,0.5,0.5))}
                                    elseif(N <= 0.3) {V:setMaterial("models/props_c17/metalladder002")}
                                    elseif(N <= 0.4) {V:setColor(V:getColor() * vec(0.7,0.6,0.6))}
                                    elseif((V:type() != "gmod_wire_gate") & (V != Base))
                                        {#ifdef entity:propDelete()
                                            V:propDelete()
                                        #endif
                                        }
                                }
                            selfDestruct()
                        }
                    #Alternatively, if you lose a "base" prop, a core and vital component, you will lose all control, but the pilot will survive.
                    else
                        {
                            #Flagged var for use later, hooray my years of coding in strong statically typed languages
                            DamageSystemTrigger = 0
                            for(N=1,DamageBaseCount)
                                {
                                    #Did we lose an important bit?
                                    if(!Bases:entity(N):isValid())
                                        {#if it's not welded, we don't give a fuck.  if it is, RIP your airframe.
                                            if(!Unwelded:number(N)) {DamageSystemTrigger++}
                                        }
                                }
                            if(DamageSystemTrigger) #if we lost an important chunk of our airframe, the vehicle fucks itself.
                                {
                                    Base:soundPlay(298,0,"ambient/materials/cartrap_explode_impact1.wav")
                                    Bases:entity(2):soundPlay(299,0,"ambient/materials/cartrap_explode_impact1.wav")
                                    Bases:entity(3):soundPlay(300,0,"ambient/materials/cartrap_explode_impact1.wav")
                                    selfDestruct()
                                }
                        }
                    DamageTimer = 10
                    #Tacking this on here
                    #hardcoded fix for holos
                    HoloVisibleUpdate = !HoloVisibleUpdate
                    if(HoloVisibleUpdate)
                        {
                            if(Piloted)
                                {
                                    holoVisible(300,Others,0)
                                    holoVisible(250,Others,0)
                                    holoVisible(200,Others,0)
                                    holoVisible(201,Others,0)
                                    holoVisible(300,Pilot,1)
                                    holoVisible(250,Pilot,1)
                                    holoVisible(200,Pilot,1)
                                    holoVisible(201,Pilot,1)
                                }
                            else
                                {
                                    holoVisible(300,players(),0)
                                    holoVisible(250,players(),0)
                                    holoVisible(200,players(),0)
                                    holoVisible(201,players(),0)
                                }
                        }
                }
            
            #if autopilot is on we do this
            if(APOn)
                {   
                    if(changed(APOn))
                        {AP_CurrentIndex = 1
                        if((AP_Loop:x() + AP_Loop:y()) ==0) {AP_Loop = vec2(99,99)}}#Prevents it from initting, not finding a loop, and killing itself.

                    Aimpos = AP_Waypoints:vector(AP_CurrentIndex)
                    CurrentPos = entity():pos()
                    #if in range it switches to a new point
                    if(Aimpos == vec(0,0,0))
                        {Seat:hintDriver("Autopilot disengaged",3)
                        APOn = 0}
                    elseif((Aimpos-CurrentPos):length() < (Velocity:length()))
                        {if(AP_CurrentIndex >= AP_Loop:y()) {AP_CurrentIndex = AP_Loop:x()}
                        else {AP_CurrentIndex++}}
                        
                        DifferenceOfPositions = CurrentPos - Aimpos
                        FlightHeading = getHeadingAutoroll(Aimpos,15,Flight_CPU_Angle,FlightModel_SelfLeveling,CyclicRatio,Position)
                        if(!FlightModel_Cyclic)
                            {Input_WS = FlightHeading:pitch()}
                        else
                            {Temp_APVel = Velocity:length()
                            TempCompare = clamp((Aimpos-CurrentPos):z() / (500 + (Temp_APVel*1.5)),-1,1)
                            Raw_WS = clamp((TempCompare * 10)-5,entity():angles():pitch()-15,entity():angles():pitch())
                            Input_WS = clamp(Raw_WS/10,-1,1)}
                            Input_AD = -Flight_CPU_Angle:roll() + (FlightHeading:roll()* ((FlightModel_Maneuverability:roll() / FlightModel_Maneuverability:yaw()) * 90))
                            Input_UD = clamp(TempCompare - (Velocity:z() / 250),-1,1)
                            Input_LR = FlightHeading:yaw()
                            Input_FB = Pod:number("W") - Pod:number("S")
                            #Actual mobility is overridden
                            WS = getSmoothedOutput(WS,Input_WS,Smoothers)
                            AD = getSmoothedOutput(AD,Input_AD,1)
                            LR = getSmoothedOutput(LR,Input_LR,Smoothers)
                            UD = getAccumulatedValue(UD,Input_UD,CollectiveSmoother,0,1)
                            FB = getAccumulatedValue(FB,Input_FB,ThrustSmoother,0,1)
                }
            else
                {
                    #resetting input with changed control scheme
                    if(changed(ControlScheme))
                        {
                            WS = 0
                            AD = 0
                            LR = 0
                        }
                    #Applying inputs
                    if(Pilot:keyPressed("L"))
                        {Input_WS = clamp((entity():angles():pitch()/90),-0.5,0.5)
                        Hide_Beacon = 0
                        Input_UD = clamp(TempCompare - (Velocity:z() / 250),-1,1)
                        Input_AD = -clamp((entity():angles():roll()/90),-0.5,0.5)}
                    else
                        {Hide_Beacon = !(Pilot:keyPressed("LControl"))}
                    WS = getSmoothedOutput(WS,Input_WS,UsedSmoother)
                    AD = getSmoothedOutput(AD,Input_AD,UsedSmoother)
                    LR = getSmoothedOutput(LR,Input_LR,UsedSmoother)
                    UD = getAccumulatedValue(UD,Input_UD,CollectiveSmoother,0,1)
                    FB = getAccumulatedValue(FB,Input_FB,ThrustSmoother,0,1)
                }

            #Building angular rotation & directional force models
            if(FlightModel_Wings)#if it has wings, it must make lift from them
                {
                    FlapAdjustedStall = FlightModel_Stall * (1-(UD * Flap_Effectiveness))
                    Lift_Ratio = clamp((abs(Velocity:x()) / FlightModel_Stall),0,1) #creates a ratio of lift, as you go faster it increases until you hit cruising speed
                    Control_Ratio = clamp(Lift_Ratio,0.3,1) #Creates a ratio off the lift ratio for control surface mobility
                    Flap_Dampening = 1 + ((Flap_Effectiveness*UD)*2)
                    Plane_Lift_Adjustment = Lift_Ratio * Flap_Dampening * 1.5 * FlightModel_Wings
                }    
            if(FlightModel_Collective)#if it has rotors, make it lift from those
                {
                    Collective_Force = UD * (1-(FB*FlightModel_CollectiveThrottleBlending))
                }
            if(FlightModel_ForwardEngineThrust)#if it has thrust, it should use that.
                {
                    Thrust_Force = (FB * (1-(UD*FlightModel_CollectiveThrottleBlending))) * FlightModel_ForwardEngineThrust
                }
            if(FlightModel_Cyclic)#if it has cyclic, that could be useful to us as well.
                {
                    AngForCyclic = clamp(Angle,ang(-30,0,-30),ang(30,0,30))
                    Cyclic = vec(AngForCyclic:pitch(),-AngForCyclic:roll(),0)/30
                    if(FlightModel_CyclicTailMixing) {CyclicTailAddition = (Cyclic:x() * -Cyclic:z()) * FlightModel_CyclicTailMixing * 0.75}#Drift from cyclic
                }
                
            #Computing flight characteristics into raw values.
            Flight_CPU_Vector = entity():toWorld(((vec(Thrust_Force,0,clamp(Collective_Force+Lift_Ratio,0,1)) + Cyclic) * FlightModel_Thrust) + ((Velocity*FlightModel_Damping*Flap_Dampening*(vec(1,1,1+Plane_Lift_Adjustment))))) - Position
            Flight_CPU_Angle = freeRotateAngle(Flight_CPU_Angle,(WS*FlightModel_Maneuverability:pitch())*Control_Ratio,((CyclicTailAddition-LR)*FlightModel_Maneuverability:yaw())*Control_Ratio,(AD*FlightModel_Maneuverability:roll())*Control_Ratio)
            
            #Quaternion direction rotation finding--translates angles of flight CPU to prop forces.  Works fairly well, I'm sure there's a more efficient way.
            Current_Quat = quat(entity())
            Desired_Quat = quat(angnorm(Flight_CPU_Angle+ang(FixedTrim,0,0)))
            Q = Desired_Quat/Current_Quat
            V = (rotationVector(Q)+Position)
            
            #Application of actual force
            for(X=1,Bases:count())
                {
                    Entity_To_Apply_Force_To = Bases:entity(X)
                    Entity_To_Apply_Force_To_Mass = Entity_To_Apply_Force_To:mass()
                    if(!Unwelded:number(X)) {Entity_To_Apply_Force_To:applyTorque((((Entity_To_Apply_Force_To:toLocal(rotationVector(Q)+Entity_To_Apply_Force_To:pos()))*AngularForce) - (AngularDamping*(Entity_To_Apply_Force_To:angVelVector()))) * -(Inertias:vector(X)*Entity_To_Apply_Force_To_Mass))}
                    Entity_To_Apply_Force_To:applyForce((Flight_CPU_Vector)*Entity_To_Apply_Force_To_Mass)#Masses:number(X))
                    X++
                }
        }
    if(FireSpecial) {Aimpos = Saved_Aimpos + (Cam:vector("CamDir")*50)} else {Aimpos = Saved_Aimpos}#Restoring aimpos, because we screw with it sometimes in processing.  If we're holding missile fire, it'll output some point hurrfar in the future
    }
}

###################################################################################################
#Here's a copy of varlib, copy-paste into a new e2
###################################################################################################
#[
@name MPFC v6 VarLib
@outputs [VarLib]:array
@model models/bull/gates/microcontroller1_mini.mdl
#FLIGHT MODELS:
#0------------Glider
#1------------Biplane
#2------------Parasol plane
#3------------Monoplane
#4------------Jumpjet
#5------------Airship
#6------------Helicopter
#7------------Gyrodyne
#8------------Autogyro

#Varlib for flight chip
Maneuverability = 1			#modifier for maneuverability
Thrust = 1					#forward or lateral thrust, it's all meshed the same
Lift = 1			#Lift force ratio, may adjust to work with some autohovering governor
Cruisespeed = 1000				#max lift at this, used to create stall ratios
Typeofvehicle = 1			#selects flight model
#Personal preferences
Smoothers = 0.1				#Smooths inputs
CollectiveSmoother = 0.05		#smoother for collective only
ThrustSmoother = 0.05			#smoother for thrust only
#Sounds
CockpitSound = "acf_extra/airfx/cockpit_heli2.wav"			#Sound that plays in the cockpit
EngineSound = "acf_extra/vehiclefx/engines/jetstart.wav"				#Sound that plays from engine
PropSound = "acf_extra/airfx/apache_loop.wav"				#Sound that plays from rotors or thrusting, static and unchanging.
SwitchSound = "buttons/lever7.wav"				#Sound that plays when you switch master circuit
GetInSound = "buttons/latchunlocked2.wav"				#Sound that plays when someone gets in the seat
StartSound = "acf_extra/vehiclefx/starters/mammutstart.wav"      #Sound that plays as the engine turns over
#Interface
Metric = 1      #Do you believe that shutting your own government down is NOT viable political policy?        
#Optional holo
Scale = vec(1,1,1)          #Scale of your main rotors
RotorBlades = 5             #Blades on main rotors
TailScale = vec(1.5,1.5,1.5)      #Scale of your tail rotor
TailRotorBlades = 3         #Blades on tail rotor
PropellorScale = 1 #Size of your propellors
PropellorBlades = 5 #Blades on your propellors
TailAngleSwap = 1 #0 or 1, swaps the side the tail rotor is on
#Cam
CamOffset = vec(0,0,50)

#Building Variable libraries
VarLib = array(Maneuverability,Thrust,Lift,Cruisespeed,Typeofvehicle,Smoothers,CollectiveSmoother,ThrustSmoother,15,vec(0,0,0),CockpitSound,EngineSound,PropSound,SwitchSound,GetInSound,StartSound,Metric,Scale,RotorBlades,TailScale,TailRotorBlades,PropellorScale,PropellorBlades,TailAngleSwap,CamOffset)

@name MPFC v6 VarLib
@outputs [VarLib]:array
@model models/bull/gates/microcontroller1_mini.mdl
#FLIGHT MODELS:
#0------------Glider
#1------------Biplane
#2------------Parasol plane
#3------------Monoplane
#4------------Jumpjet
#5------------Airship
#6------------Helicopter
#7------------Gyrodyne
#8------------Autogyro

#Varlib for flight chip
Maneuverability = 1			#modifier for maneuverability
Thrust = 1					#forward or lateral thrust, it's all meshed the same
Lift = 1			#Lift force ratio, may adjust to work with some autohovering governor
Cruisespeed = 1000				#max lift at this, used to create stall ratios
Typeofvehicle = 1			#selects flight model
#Personal preferences
Smoothers = 0.1				#Smooths inputs
CollectiveSmoother = 0.05		#smoother for collective only
ThrustSmoother = 0.05			#smoother for thrust only
#Sounds
CockpitSound = "acf_extra/airfx/cockpit_heli2.wav"			#Sound that plays in the cockpit
EngineSound = "acf_extra/vehiclefx/engines/jetstart.wav"				#Sound that plays from engine
PropSound = "acf_extra/airfx/apache_loop.wav"				#Sound that plays from rotors or thrusting, static and unchanging.
SwitchSound = "buttons/lever7.wav"				#Sound that plays when you switch master circuit
GetInSound = "buttons/latchunlocked2.wav"				#Sound that plays when someone gets in the seat
StartSound = "acf_extra/vehiclefx/starters/mammutstart.wav"      #Sound that plays as the engine turns over
#Interface
Metric = 1      #Do you believe that shutting your own government down is NOT viable political policy?        
#Optional holo
Scale = vec(1,1,1)          #Scale of your main rotors
RotorBlades = 5             #Blades on main rotors
TailScale = vec(1.5,1.5,1.5)      #Scale of your tail rotor
TailRotorBlades = 3         #Blades on tail rotor
PropellorScale = 1 #Size of your propellors
PropellorBlades = 5 #Blades on your propellors
TailAngleSwap = 1 #0 or 1, swaps the side the tail rotor is on
#Cam
CamOffset = vec(0,0,50)

#Building Variable libraries
VarLib = array(Maneuverability,Thrust,Lift,Cruisespeed,Typeofvehicle,Smoothers,CollectiveSmoother,ThrustSmoother,15,vec(0,0,0),CockpitSound,EngineSound,PropSound,SwitchSound,GetInSound,StartSound,Metric,Scale,RotorBlades,TailScale,TailRotorBlades,PropellorScale,PropellorBlades,TailAngleSwap,CamOffset)


